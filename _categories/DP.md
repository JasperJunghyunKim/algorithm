### 개념

* Dynamic Programming (동적 계획법)
* 복잡한 문제를 더 작은 하위 문제로 나누어 해결하는 알고리즘 설계 기법
* 중복된 형태의 하위 문제의 결과를 저장하고 재활용 함으로써, 계산 효율성을 향상시키는 것이 핵심

**DP 기법을 적용시킬 수 있는 조건**
1. 중복되는 부분 문제
   문제를 나누고 그 문제의 결과 값을 재활용해서 전체 답을 구함
   따라서 동일한 작은 문제들이 반복하여 나타나는 경우에 사용 가능
2. 중복되는 부분 문제
   큰 문제의 최적 해결책이 그 문제의 부분 문제들의 최적 해결책으로부터 구성될  수 있음을 의미
   즉, 전체 문제의 해가 부분 문제의 해에서 유도될 수 있을 때 사용 가능


---
### 구현

1. DP 배열을 정의한다. 
   * 예) i 번째까지 실행했을 때의 최적해
2. DP 배열의 점화식을 찾는다. 2, 3차원 배열이될 수도 있으며, 배열 간 서로 영향을 줄 수도 있음
3. Bottom Up 또는 Top Down 중 적절한 방식으로 구현한다.

### 구현_Bottom Up (Tabulation 방식)

* 작은 문제부터 차례대로 해결하면서 그 결과를 테이블에 저장하고, 이 테이블 값을 이용하여 점차 큰 문제의 해결책을 구성해 나감
* 일반적으로 반복문을 이용하여 구현

### 구현_Top Down (Memoization 방식)

* 큰 문제를 작은 부분 문제로 나누어 해결하는 방식
* 이를 위해 재귀함수를 사용하여 문제를 작은 부분 문제로 쪼개고, 중복되는 계산을 피하기 위해 Memoization 을 활용

### 구현 비교 - Top Down vs Bottom Up

**Bottom Up** 
* 반복문을 순회하며 작은 문제의 결과를 테이블에 저장하므로, 코드가 일반적으로 더 직관적임
* 반복문만 사용하므로 재귀 호출의 오버헤드와 스택 오버플로우의 위험이 없음
* 그러나, 전체 문제 공간을 미리 정의해야되며 모든 하위 문제를 해결해야만 최종 문제를 해결할 수 있음
	* 그러니 전체 공간을 정의하는 것은, '나머지' 를 활용하는 방식으로 테이블 길이를 단축시킬 수 있음

**Top Down**
* 필요한 하위 문제만을 해결하기 때문에, 불필요한 계산을 줄일 수 있음
* 모든 하위 문제의 해를 저장해야되므로, 메모리 사용량이 증가할 수 있음
* 재귀 호출에 따른 오버헤드 및 깊은 재귀로 인한 스택 오버플로우


---
### 유형

* 피보나치 수
- 0-1 Knapsack Problem
- 길이 N 배열 여러개가 서로 영향을 주는 점화식
  예) [RGB 거리](https://www.acmicpc.net/problem/1149)
- 최장 증가 부분 수열(Longest Increasing Subsequence, LIS)
- 최장 공통 부분 수열(Longest Common Subsequence, LCS)


---
### ⚠️ 주의

### 참고

### 정리중
