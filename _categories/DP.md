##### A. 원리
- 문제를 나누고, 그 문제의 결과 값을 재활용하여 전체 답을 구함
- 동일한 작은 문제들이 반복하여 나타나는 경우에 사용 가능
- 부분 문제의 최적 결과값이 전체 문제의 최적 결과를 낼 수 있는 경우 사용 가능
##### B. 접근, 구현 방법
1. 점화식 만들기
	* 점화식(일반적으로 DP 배열)의 의미부터 정리
	* 예) i 번째까지 실행했을 때의 최적해
2. Bottom Up (Tabulation)
	- 직관적으로 접근 가능 (선형적으로 해결하므로)
	- 반복적으로 부분 문제를 해결하고, 결과를 배열 등에 저장
3. Top Down (Recursive) + Memoization
4. Memoization
##### C. 유형
- 피보나치 수
- 0-1 Knapsack Problem
- 최장증가부분수열
- N x M 배열 간 영향을 주는 점화식
##### D. 정리필요
- 구현 방법 Bottom Up, Top Down 비교
	- 둘 다 점화식은 동일
	- 구현 방법에 있어선 Bottom Up 방식이 비교적 직관적으로 접근 가능 -> Linear 하게 해결하므로
	- 그러나 Top Down 은 재귀 함수를 사용하므로 Recursive Error 가 발생할 수 있음
	- 메모리 접근
	- ... 반면 Top Down 는 필요한 부분만 해결하므로 성능적으로 우수할 수 도 있음
	- ...
	- ...
	- 동적 프로그래밍(Dynamic Programming, DP) 문제를 풀 때 Top-down(메모이제이션) 방식과 Bottom-up(타뷸레이션) 방식을 선택할 수 있으며, 두 방식은 각각 재귀 함수와 반복문을 기반으로 합니다. 이론적으로, 두 방식이 해결하는 서브 문제의 수와 연산의 양이 같다면, 시간 복잡도는 동일합니다. 그러나 실제로는 몇 가지 이유로 인해 성능 차이가 발생할 수 있습니다:
	
	1. **함수 호출 오버헤드**: Top-down 방식은 재귀 함수 호출을 사용하기 때문에, 함수 호출 스택과 관련된 오버헤드가 발생합니다. 반면, Bottom-up 방식은 반복문을 사용하므로 이러한 오버헤드가 없습니다. 따라서, 같은 문제를 해결할 때 Bottom-up 방식이 좀 더 효율적일 수 있습니다.
	
	2. **메모리 접근 패턴**: Bottom-up 방식은 일반적으로 메모리에 순차적으로 접근합니다. 이는 CPU 캐시 활용성을 높여 성능을 향상시킬 수 있습니다. Top-down 방식에서는 재귀의 깊이와 순서에 따라 메모리 접근 패턴이 불규칙할 수 있어, 상대적으로 캐시 효율이 떨어질 수 있습니다.
	
	3. **스택 오버플로**: 깊은 재귀를 사용하는 Top-down 방식은 스택 오버플로를 일으킬 위험이 있습니다. 특히, 문제의 크기가 매우 클 경우 이러한 위험이 커집니다. Bottom-up 방식은 이러한 제한이 없습니다.
	
	4. **서브 문제의 재사용**: Top-down 방식은 필요한 서브 문제만을 정확히 해결하여 메모이제이션합니다. 반면, Bottom-up 방식은 모든 서브 문제를 처음부터 차례대로 해결합니다. 따라서, 특정 조건에서는 Top-down 방식이 더 적은 수의 서브 문제를 해결함으로써 성능 이점을 가질 수 있습니다.
	
	결론적으로, Top-down과 Bottom-up 방식 모두 동일한 문제를 해결하기 위해 동일한 수의 서브 문제를 해결하지만, 함수 호출 오버헤드, 메모리 접근 패턴, 스택 오버플로의 위험 등의 차이로 인해 실제 실행 시간에서 차이가 발생할 수 있습니다. 일반적으로 Bottom-up 방식이 더 효율적이라고 평가되는 경우가 많으나, 실제 성능은 문제의 성격, 구현 방법, 사용 환경에 따라 달라질 수 있습니다. 따라서, 어떤 방식이 더 나은지를 판단하기 위해서는 직접 구현해보고 성능을 비교하는 것이 좋습니다.
